# 📘 משתנים וקטגוריות זיכרון – Mutables vs. Immutables

## ✨ הסבר
כשאנחנו יוצרים משתנה בפייתון, המערכת שומרת אותו בזיכרון. 

אבל יש שני סוגים עיקריים של משתנים – כאלה שאפשר לשנות את התוכן שלהם (**mutables**) וכאלה שלא ניתן לשנות אותם אחרי שנוצרו (**immutables**). 

ההבדל הזה משפיע על ביצועים, זיכרון, תקלות מבלבלות – ובאופן כללי על איך להבין את הקוד שלך.

## 🧠 מה נלמד בפרק הזה?
- מה זה משתנה "immutable" ומה זה "mutable"
- דוגמאות קלאסיות לשני הסוגים
- מה קורה בזיכרון כשמשנים ערך
- למה זה משפיע על תקלות נפוצות ו־debugging
- תובנות על שיתוף אובייקטים בין משתנים

## 🔍 הסברים ודוגמאות

### 🔒 מה זה Immutable?
- **ערך שלא ניתן לשנות לאחר יצירתו**
- אם משנים – בעצם יוצרים עותק חדש.

📌 דוגמאות:
```python
x = 5          # int → immutable
x = x + 1      # נוצר מספר חדש 6
````

```python
name = "Dvir"  # str → immutable
name += " Cabessa"  # נוצר מחרוזת חדשה
```

### 🔓 ומה זה Mutable?

* **אובייקט שאפשר לשנות את התוכן שלו בלי לשנות את הכתובת בזיכרון**

📌 דוגמאות:

```python
my_list = [1, 2, 3]
my_list.append(4)  # הרשימה עצמה משתנה במקום
```

```python
person = {"name": "Alice"}
person["name"] = "Bob"  # המילון משתנה – אותו אובייקט
```

### 🧠 מה קורה בזיכרון?

* **immutable** – כל שינוי = יצירה של אובייקט חדש
* **mutable** – השינוי נעשה בתוך אותו אובייקט (אותו מזהה `id()`)

🔍 נסה:

```python
x = [1, 2]
print(id(x))  # מזהה בזיכרון
x.append(3)
print(id(x))  # אותו מזהה!
```

### ⚠️ באגים נפוצים

* שיתוף רשימות בין משתנים:

```python
a = [1, 2]
b = a
b.append(3)
print(a)  # גם a השתנתה!
```

💡 הפתרון: להשתמש ב־`.copy()` או `list(a)` כדי ליצור עותק אמיתי (deep copy)

### 🧪 סיכום סוגי משתנים

| טיפוס נתונים | Mutable? |
| ------------ | -------- |
| int          | ❌        |
| float        | ❌        |
| str          | ❌        |
| tuple        | ❌        |
| list         | ✅        |
| dict         | ✅        |
| set          | ✅        |

## 💡 טיפים מתקדמים

* משתנים אימיוטבליים נחשבים **בטוחים יותר** – אי אפשר לשנות אותם בטעות.
* בפונקציות, זה קריטי לדעת אם אתה משנה את המשתנה המקורי או רק עותק – במיוחד עם רשימות או מילונים.

## ✅ בדוק את עצמך

1. מה יקרה אם נעביר רשימה לפונקציה ונשנה אותה בפנים?
2. מה ההבדל בזיכרון בין `x = x + 1` לבין `x.append(1)`?
3. למה כדאי לדעת אם אובייקט הוא mutable או לא?

