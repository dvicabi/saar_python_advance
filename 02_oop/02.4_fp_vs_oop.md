# 📘על OOP מול FP – השוואה בין תכנות מונחה עצמים לתכנות פונקציונלי

## ✨ הסבר
בעולם התכנות קיימות גישות שונות לפתרון בעיות. 

שתי הגישות המרכזיות הן **תכנות מונחה עצמים (OOP)** ו־**תכנות פונקציונלי (FP)**. 

לכל אחת יתרונות, סגנון שונה, והקשרים שבהם היא עדיפה. נלמד את ההבדלים העקרוניים, ונראה דוגמאות קודיות שמשוות את הגישות.

## 🧠 מה נלמד בפרק הזה?
- מהו OOP ומהו FP
- השוואת עקרונות תכנון – מודולריות, מצב (state), היררכיה
- מתי נעדיף כל אחת מהגישות
- דוגמה לפתרון בעיה בגישת OOP מול FP
- יתרונות וחסרונות של כל גישה

---

## 🔍 הסברים ודוגמאות

### 🧱 מהו OOP?

- מבוסס על **מחלקות ואובייקטים**
- לכל אובייקט יש **מצב (state)** ו־**התנהגות (methods)**
- מאפשר מודולריות, הרחבה, והסתרת מידע (encapsulation)

```python
class Circle:
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2
````

---

### 🔁 מהו FP?

* מבוסס על **פונקציות טהורות** – אין שינויים במצב
* אין אובייקטים – הנתונים עוברים כפלט/קלט של פונקציות
* כל פעולה = פונקציה שמקבלת ערכים ומחזירה תוצאה

```python
def area(radius):
    return 3.14 * radius ** 2
```

---

### 📊 השוואה כללית

| קריטריון               | OOP                 | FP                                      |
| ---------------------- | ------------------- | --------------------------------------- |
| מבנה בסיסי             | מחלקות ואובייקטים   | פונקציות בלבד                           |
| ניהול מצב (state)      | יש – לכל אובייקט    | אין – פונקציות טהורות בלבד              |
| הרחבה                  | ירושה, Polymorphism | קומפוזיציה, פונקציות גבוהות סדר         |
| התאמה לפרויקטים גדולים | מעולה לניהול ישויות | מעולה לחישובים טהורים או data pipelines |
| דוגמה לשימוש           | משחק, מערכת הרשאות  | עיבוד דאטה, אלגוריתמיקה, חישוב מתמטי    |

---

### 🧪 אותה בעיה – פתרון ב־OOP:

```python
class Student:
    def __init__(self, name, grades):
        self.name = name
        self.grades = grades

    def average(self):
        return sum(self.grades) / len(self.grades)
```

---

### 🧪 אותה בעיה – פתרון ב־FP:

```python
def average(grades):
    return sum(grades) / len(grades)

students = {
    "Alice": [80, 90],
    "Bob": [70, 75]
}

for name, grades in students.items():
    print(f"{name} → {average(grades)}")
```

---

## 💡 טיפים מתקדמים

* ב־FP משתמשים הרבה ב־`map()`, `filter()`, `lambda` ו־`reduce`
* ב־OOP קל **לאגד פונקציות שקשורות לאותו אובייקט**
* ניתן **לשלב** בין הגישות – וזה מקובל מאוד בפרויקטים מודרניים

---

## ✅ בדוק את עצמך

1. מה ההבדל העיקרי בין OOP ל־FP מבחינת ניהול מצב?
2. מתי תעדיף תכנות פונקציונלי?
3. כיצד נפתור בעיה מתמטית בצורה "טהורה" בלי מצב?
